"""
Simple demo version for better input visibility
"""
import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from model_loader import load_models
from batch_prediction import render_batch_prediction_page

# Helper functions for SHAP-like analysis
def calculate_income_impact(income, loan_amount):
    """Calculate income impact on loan approval"""
    debt_to_income = loan_amount / income
    if income < 40000:
        return -0.0234 if debt_to_income > 0.3 else -0.0156
    elif income < 60000:
        return -0.0089 if debt_to_income > 0.4 else 0.0023
    else:
        return 0.0156 if debt_to_income < 0.3 else 0.0089

def calculate_loan_amount_impact(loan_amount, income):
    """Calculate loan amount impact"""
    debt_to_income = loan_amount / income
    if debt_to_income > 0.5:
        return -0.0234
    elif debt_to_income > 0.3:
        return -0.0156
    elif debt_to_income > 0.2:
        return -0.0067
    else:
        return 0.0023

def calculate_age_impact(age):
    """Calculate age impact"""
    if age < 25:
        return -0.0034
    elif age < 35:
        return 0.0089
    elif age < 55:
        return 0.0123
    else:
        return 0.0067

def calculate_credit_history_impact(credit_length):
    """Calculate credit history impact"""
    if credit_length < 3:
        return -0.0089
    elif credit_length < 8:
        return 0.0045
    elif credit_length < 15:
        return 0.0067
    else:
        return 0.0089

def calculate_home_ownership_impact(ownership):
    """Calculate home ownership impact"""
    if ownership == 0:  # Rent
        return -0.0023
    elif ownership == 1:  # Own
        return 0.0045
    else:  # Mortgage
        return 0.0034

def calculate_employment_impact(emp_length):
    """Calculate employment length impact"""
    if emp_length < 2:
        return -0.0034
    elif emp_length < 5:
        return 0.0023
    elif emp_length < 10:
        return 0.0045
    else:
        return 0.0067

def calculate_loan_intent_impact(intent):
    """Calculate loan intent impact"""
    # 0: Personal, 1: Education, 2: Medical, 3: Venture, 4: Home improvement, 5: Debt consolidation
    intent_impacts = {0: -0.0012, 1: 0.0034, 2: 0.0023, 3: -0.0045, 4: 0.0067, 5: -0.0023}
    return intent_impacts.get(intent, 0)

def calculate_default_impact(default_history):
    """Calculate default history impact"""
    return -0.0089 if default_history == 1 else 0.0012

def get_feature_explanation(feature_name, impact, age, income, home_ownership, emp_length, 
                          loan_intent, loan_amount, default_on_file, credit_hist_length):
    """Get detailed explanation for each feature impact"""
    
    explanations = {
        'Thu nh·∫≠p (person_income)': {
            'positive': f"Thu nh·∫≠p ${income:,} c·ªßa anh/ch·ªã n·∫±m trong m·ª©c kh√° t·ªët, th·ªÉ hi·ªán kh·∫£ nƒÉng t√†i ch√≠nh ·ªïn ƒë·ªãnh v√† ƒë·ªß kh·∫£ nƒÉng chi tr·∫£ kho·∫£n vay.",
            'negative': f"Thu nh·∫≠p hi·ªán t·∫°i ${income:,} c·ªßa anh/ch·ªã th·∫•p h∆°n m·ª©c trung b√¨nh m√† ch√∫ng t√¥i th∆∞·ªùng ch·∫•p thu·∫≠n, ƒë√¢y l√† y·∫øu t·ªë c·∫£n tr·ªü l·ªõn nh·∫•t trong quy·∫øt ƒë·ªãnh n√†y."
        },
        'S·ªë ti·ªÅn vay (loan_amnt)': {
            'positive': f"Kho·∫£n vay ${loan_amount:,} ph√π h·ª£p v·ªõi kh·∫£ nƒÉng t√†i ch√≠nh hi·ªán t·∫°i c·ªßa anh/ch·ªã, t·∫°o √°p l·ª±c tr·∫£ n·ª£ ·ªü m·ª©c h·ª£p l√Ω.",
            'negative': f"Kho·∫£n vay ${loan_amount:,} t∆∞∆°ng ƒë·ªëi cao so v·ªõi kh·∫£ nƒÉng t√†i ch√≠nh hi·ªán t·∫°i (t·ª∑ l·ªá {(loan_amount/income)*100:.1f}% thu nh·∫≠p), t·∫°o √°p l·ª±c tr·∫£ n·ª£ ƒë√°ng k·ªÉ."
        },
        'Tu·ªïi (person_age)': {
            'positive': f"ƒê·ªô tu·ªïi {age} c·ªßa anh/ch·ªã n·∫±m trong kho·∫£ng thu·∫≠n l·ª£i, th·ªÉ hi·ªán s·ª± ·ªïn ƒë·ªãnh v√† kinh nghi·ªám trong c√¥ng vi·ªác.",
            'negative': f"ƒê·ªô tu·ªïi {age} c√≤n t∆∞∆°ng ƒë·ªëi tr·∫ª, c√≥ th·ªÉ ch∆∞a c√≥ ƒë·ªß kinh nghi·ªám t√†i ch√≠nh v√† ·ªïn ƒë·ªãnh trong c√¥ng vi·ªác."
        },
        'L·ªãch s·ª≠ t√≠n d·ª•ng (cb_person_cred_hist_length)': {
            'positive': f"Anh/ch·ªã c√≥ {credit_hist_length} nƒÉm l·ªãch s·ª≠ t√≠n d·ª•ng kh√° t·ªët, ƒëi·ªÅu n√†y th·ªÉ hi·ªán s·ª± uy t√≠n trong vi·ªác th·ª±c hi·ªán c√°c cam k·∫øt t√†i ch√≠nh.",
            'negative': f"L·ªãch s·ª≠ t√≠n d·ª•ng {credit_hist_length} nƒÉm c√≤n t∆∞∆°ng ƒë·ªëi ng·∫Øn, ch∆∞a ƒë·ªß ƒë·ªÉ ƒë√°nh gi√° ƒë·∫ßy ƒë·ªß th√≥i quen t√†i ch√≠nh."
        },
        'T√¨nh tr·∫°ng s·ªü h·ªØu nh√† (person_home_ownership)': {
            'positive': "Vi·ªác s·ªü h·ªØu t√†i s·∫£n b·∫•t ƒë·ªông s·∫£n l√† ƒëi·ªÉm c·ªông t√≠ch c·ª±c trong h·ªì s∆° c·ªßa anh/ch·ªã, th·ªÉ hi·ªán t√†i s·∫£n ƒë·∫£m b·∫£o.",
            'negative': "Vi·ªác ch∆∞a s·ªü h·ªØu nh√† ri√™ng c√≥ th·ªÉ ·∫£nh h∆∞·ªüng nh·∫π ƒë·∫øn ƒë√°nh gi√° t√†i s·∫£n ƒë·∫£m b·∫£o."
        },
        'Th·ªùi gian l√†m vi·ªác (person_emp_length)': {
            'positive': f"Kinh nghi·ªám l√†m vi·ªác {emp_length} nƒÉm ·ªïn ƒë·ªãnh g√≥p ph·∫ßn t√≠ch c·ª±c v√†o ƒë√°nh gi√° kh·∫£ nƒÉng tr·∫£ n·ª£.",
            'negative': f"Th·ªùi gian l√†m vi·ªác {emp_length} nƒÉm c√≤n √≠t, c√≥ th·ªÉ ·∫£nh h∆∞·ªüng ƒë·∫øn ·ªïn ƒë·ªãnh thu nh·∫≠p trong t∆∞∆°ng lai."
        },
        'M·ª•c ƒë√≠ch vay (loan_intent)': {
            'positive': "M·ª•c ƒë√≠ch s·ª≠ d·ª•ng kho·∫£n vay ƒë∆∞·ª£c ƒë√°nh gi√° t√≠ch c·ª±c, c√≥ kh·∫£ nƒÉng t·∫°o ra gi√° tr·ªã ho·∫∑c c·∫£i thi·ªán t√¨nh h√¨nh t√†i ch√≠nh.",
            'negative': "M·ª•c ƒë√≠ch s·ª≠ d·ª•ng kho·∫£n vay c√≥ ·∫£nh h∆∞·ªüng nh·∫π ti√™u c·ª±c ƒë·∫øn quy·∫øt ƒë·ªãnh ph√™ duy·ªát."
        },
        'L·ªãch s·ª≠ n·ª£ x·∫•u (cb_person_default_on_file)': {
            'positive': "Kh√¥ng c√≥ l·ªãch s·ª≠ n·ª£ x·∫•u trong qu√° kh·ª©, th·ªÉ hi·ªán th√°i ƒë·ªô tr·∫£ n·ª£ t√≠ch c·ª±c.",
            'negative': "C√≥ d·∫•u hi·ªáu nh·ªè v·ªÅ r·ªßi ro t√≠n d·ª•ng trong qu√° kh·ª©, m·∫∑c d√π kh√¥ng nghi√™m tr·ªçng."
        }
    }
    
    explanation_type = 'positive' if impact > 0 else 'negative'
    return explanations.get(feature_name, {}).get(explanation_type, "Kh√¥ng c√≥ th√¥ng tin chi ti·∫øt.")

def generate_advice(income, loan_amount, age, emp_length, credit_hist_length, home_ownership, default_history, default_probability):
    """Generate personalized advice"""
    
    advice_parts = []
    
    if default_probability > 0.6:  # High risk
        advice_parts.append("ƒê·ªÉ c·∫£i thi·ªán h·ªì s∆° vay, anh/ch·ªã n√™n xem x√©t:")
        
        debt_to_income = loan_amount / income
        if debt_to_income > 0.3:
            reduction_percent = ((debt_to_income - 0.25) / debt_to_income) * 100
            advice_parts.append(f"‚Ä¢ Gi·∫£m s·ªë ti·ªÅn vay xu·ªëng kho·∫£ng {reduction_percent:.0f}% so v·ªõi hi·ªán t·∫°i (c√≤n kho·∫£ng ${loan_amount * (1 - reduction_percent/100):,.0f})")
        
        if income < 50000:
            target_income = income * 1.3
            advice_parts.append(f"‚Ä¢ TƒÉng thu nh·∫≠p l√™n √≠t nh·∫•t ${target_income:,.0f} (tƒÉng {((target_income - income)/income)*100:.0f}%)")
        
        if emp_length < 3:
            advice_parts.append("‚Ä¢ T√≠ch l≈©y th√™m kinh nghi·ªám l√†m vi·ªác (√≠t nh·∫•t 3 nƒÉm)")
        
        if credit_hist_length < 5:
            advice_parts.append("‚Ä¢ X√¢y d·ª±ng l·ªãch s·ª≠ t√≠n d·ª•ng t√≠ch c·ª±c th√™m v√†i nƒÉm")
            
    elif default_probability > 0.3:  # Medium risk
        advice_parts.append("H·ªì s∆° c·ªßa anh/ch·ªã c√≥ ti·ªÅm nƒÉng, c·∫ßn c·∫£i thi·ªán m·ªôt v√†i ƒëi·ªÉm:")
        
        if loan_amount / income > 0.25:
            advice_parts.append(f"‚Ä¢ Gi·∫£m nh·∫π s·ªë ti·ªÅn vay xu·ªëng kho·∫£ng ${loan_amount * 0.8:,.0f}")
        
        if income < 60000:
            advice_parts.append("‚Ä¢ TƒÉng thu nh·∫≠p ho·∫∑c c√≥ th√™m ngu·ªìn thu nh·∫≠p ph·ª•")
            
        advice_parts.append("‚Ä¢ Ti·∫øp t·ª•c duy tr√¨ l·ªãch s·ª≠ t√≠n d·ª•ng t·ªët")
        
    else:  # Low risk
        advice_parts.append("H·ªì s∆° c·ªßa anh/ch·ªã r·∫•t t·ªët! M·ªôt v√†i g·ª£i √Ω ƒë·ªÉ duy tr√¨:")
        advice_parts.append("‚Ä¢ Ti·∫øp t·ª•c duy tr√¨ thu nh·∫≠p ·ªïn ƒë·ªãnh")
        advice_parts.append("‚Ä¢ Gi·ªØ t·ª∑ l·ªá n·ª£/thu nh·∫≠p ·ªü m·ª©c th·∫•p")
        advice_parts.append("‚Ä¢ Duy tr√¨ l·ªãch s·ª≠ t√≠n d·ª•ng t√≠ch c·ª±c")
    
    return "\n".join(advice_parts)

st.set_page_config(
    page_title="Demo D·ª± ƒêo√°n R·ªßi Ro Vay V·ªën",
    page_icon="üéØ",
    layout="wide"
)

def main():
    st.title("ü§ñ AI Model Analysis & Prediction Dashboard")
    
    # Sidebar navigation
    st.sidebar.title("üß≠ ƒêi·ªÅu H∆∞·ªõng")
    page = st.sidebar.selectbox(
        "Ch·ªçn trang:",
        ["üéØ Demo D·ª± ƒêo√°n", "üìä D·ª± ƒêo√°n H√†ng Lo·∫°t (CSV)", "üß† Ph√¢n T√≠ch LORA Model", "üå≥ Ph√¢n T√≠ch LightGBM", "üìä Feature Importance"]
    )
    
    # Load model - Remove cache to ensure SHAP explainer is properly loaded
    def load_model():
        return load_models(".")
    
    loader = load_model()
    
    # Check SHAP explainer status for sidebar
    if hasattr(loader, 'shap_explainer') and loader.shap_explainer:
        st.sidebar.success("‚úÖ SHAP TreeExplainer loaded")
    else:
        st.sidebar.warning("‚ö†Ô∏è SHAP TreeExplainer not available")
    
    if page == "üéØ Demo D·ª± ƒêo√°n":
        render_prediction_page(loader)
    elif page == "üìä D·ª± ƒêo√°n H√†ng Lo·∫°t (CSV)":
        render_batch_prediction_page(loader)
    elif page == "üß† Ph√¢n T√≠ch LORA Model":
        render_lora_analysis(loader)
    elif page == "üå≥ Ph√¢n T√≠ch LightGBM":
        render_lightgbm_analysis(loader)
    elif page == "üìä Feature Importance":
        render_feature_importance(loader)

def render_prediction_page(loader):
    st.markdown("# üéØ Demo D·ª± ƒêo√°n R·ªßi Ro Vay V·ªën")
    st.markdown("### ƒêi·ªÅn th√¥ng tin d∆∞·ªõi ƒë√¢y ƒë·ªÉ d·ª± ƒëo√°n kh·∫£ nƒÉng ƒë∆∞·ª£c duy·ªát cho vay")
    
    if loader.lightgbm_model is None:
        st.error("‚ùå Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh LightGBM")
        return
    
    st.success("‚úÖ M√¥ h√¨nh ƒë√£ s·∫µn s√†ng!")
    
    # Main layout: Left for inputs, Right for results
    main_col1, main_col2 = st.columns([1, 1])
    
    with main_col1:
        st.markdown("## üìù TH√îNG TIN ƒê·∫¶U V√ÄO")
        
        # Create two sub-columns for inputs
        input_col1, input_col2 = st.columns(2)
        
        with input_col1:
            st.markdown("#### üë§ Th√¥ng Tin C√° Nh√¢n")
            
            # Age slider
            person_age = st.slider(
                "üéÇ Tu·ªïi c·ªßa b·∫°n", 
                min_value=18, max_value=80, value=35, step=1
            )
            st.write(f"Tu·ªïi ƒë∆∞·ª£c ch·ªçn: **{person_age} tu·ªïi**")
            
            # Income input
            person_income = st.number_input(
                "üí∞ Thu nh·∫≠p h√†ng nƒÉm (USD)", 
                min_value=10000, max_value=500000, value=75000, step=1000
            )
            st.write(f"Thu nh·∫≠p: **${person_income:,}**")
            
            # Home ownership
            home_options = ["Thu√™ nh√†", "S·ªü h·ªØu", "Th·∫ø ch·∫•p"]
            home_ownership_text = st.selectbox("üè† T√¨nh tr·∫°ng nh√† ·ªü", home_options)
            home_ownership = home_options.index(home_ownership_text)
            st.write(f"Nh√† ·ªü: **{home_ownership_text}**")
            
            # Employment length
            emp_length = st.slider(
                "üíº S·ªë nƒÉm l√†m vi·ªác", 
                min_value=0, max_value=20, value=5, step=1
            )
            st.write(f"Kinh nghi·ªám: **{emp_length} nƒÉm**")
        
        with input_col2:
            st.markdown("#### üí∞ Th√¥ng Tin Kho·∫£n Vay")
            
            # Loan intent
            intent_options = ["C√° nh√¢n", "Gi√°o d·ª•c", "Y t·∫ø", "Kinh doanh", "C·∫£i thi·ªán nh√†", "Tr·∫£ n·ª£"]
            loan_intent_text = st.selectbox("üéØ M·ª•c ƒë√≠ch vay", intent_options)
            loan_intent = intent_options.index(loan_intent_text)
            st.write(f"M·ª•c ƒë√≠ch: **{loan_intent_text}**")
            
            # Loan amount
            loan_amount = st.number_input(
                "üíµ S·ªë ti·ªÅn mu·ªën vay (USD)", 
                min_value=1000, max_value=50000, value=10000, step=500
            )
            st.write(f"S·ªë ti·ªÅn vay: **${loan_amount:,}**")
            
            # Default history
            default_options = ["Kh√¥ng", "C√≥"]
            default_text = st.selectbox("‚ö†Ô∏è ƒê√£ t·ª´ng v·ª° n·ª£ tr∆∞·ªõc ƒë√¢y?", default_options)
            default_on_file = default_options.index(default_text)
            st.write(f"L·ªãch s·ª≠ v·ª° n·ª£: **{default_text}**")
            
            # Credit history length
            credit_hist_length = st.slider(
                "üìä S·ªë nƒÉm c√≥ l·ªãch s·ª≠ t√≠n d·ª•ng", 
                min_value=0, max_value=25, value=10, step=1
            )
            st.write(f"L·ªãch s·ª≠ t√≠n d·ª•ng: **{credit_hist_length} nƒÉm**")
        
        # Predict button
        st.markdown("---")
        predict_button = st.button("ÔøΩ TH·ª∞C HI·ªÜN D·ª∞ ƒêO√ÅN R·ª¶I RO", type="primary", use_container_width=True)
    
    with main_col2:
        st.markdown("## üìä K·∫æT QU·∫¢ D·ª∞ ƒêO√ÅN")
        
        if predict_button:
            # Create input array - ƒê√É S·ª¨A TH·ª® T·ª∞ FEATURES ƒê√öNG V·ªöI MODEL
            input_data = np.array([[
                person_age, person_income, home_ownership, emp_length,
                loan_intent, loan_amount, default_on_file, credit_hist_length
            ]])
            
            try:
                with st.spinner("üîÑ ƒêang ph√¢n t√≠ch r·ªßi ro..."):
                    prediction = loader.predict_lightgbm(input_data)[0]
                    # Raw prediction t·ª´ model n√†y l√† approval probability
                    approval_probability = prediction  
                    default_probability = 1 - approval_probability  # T·ª∑ l·ªá v·ª° n·ª£ = 1 - t·ª∑ l·ªá ƒë∆∞·ª£c duy·ªát
                
                st.markdown("---")
                st.markdown("### üìä K·∫æT QU·∫¢ PH√ÇN T√çCH")
                
                # Display result in columns
                result_col1, result_col2 = st.columns([1, 1])
                
                with result_col1:
                    # Risk level determination and decision
                    if default_probability > 0.7:
                        decision = "T·ª™ CH·ªêI"
                        risk_level = "R·ª¶I RO CAO"
                        risk_color = "red"
                        risk_emoji = "‚ùå"
                        decision_reason = "D·ª±a tr√™n ph√¢n t√≠ch AI, h·ªì s∆° n√†y c√≥ t·ª∑ l·ªá duy·ªát th·∫•p do nhi·ªÅu y·∫øu t·ªë ti√™u c·ª±c v∆∞·ª£t tr·ªôi h∆°n c√°c y·∫øu t·ªë t√≠ch c·ª±c."
                    elif default_probability > 0.4:
                        decision = "C·∫¶N XEM X√âT"
                        risk_level = "R·ª¶I RO TRUNG B√åNH"
                        risk_color = "orange"
                        risk_emoji = "‚ö†Ô∏è"
                        decision_reason = "H·ªì s∆° c√≥ c·∫£ y·∫øu t·ªë t√≠ch c·ª±c v√† ti√™u c·ª±c, c·∫ßn ƒë√°nh gi√° th√™m th√¥ng tin tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh cu·ªëi c√πng."
                    else:
                        decision = "CH·∫§P THU·∫¨N"
                        risk_level = "R·ª¶I RO TH·∫§P"
                        risk_color = "green"
                        risk_emoji = "‚úÖ"
                        decision_reason = "D·ª±a tr√™n ph√¢n t√≠ch AI, h·ªì s∆° n√†y c√≥ nhi·ªÅu y·∫øu t·ªë t√≠ch c·ª±c v∆∞·ª£t tr·ªôi, kh·∫£ nƒÉng tr·∫£ n·ª£ cao."
                    
                    st.markdown(f"### üìä PH√ÇN T√çCH QUY·∫æT ƒê·ªäNH CHO H·ªí S∆† VAY")
                    st.markdown(f"**Quy·∫øt ƒë·ªãnh:** {risk_emoji} **{decision}**")
                    st.markdown(f"*{decision_reason}*")
                    st.markdown(f"**T·ª∑ l·ªá ƒë∆∞·ª£c duy·ªát cho vay:** {approval_probability:.1%}")
                    st.markdown(f"**X√°c su·∫•t v·ª° n·ª£:** {default_probability:.1%}")
                
                with result_col2:
                    # Approval probability gauge
                    fig = go.Figure(go.Indicator(
                        mode = "gauge+number",
                        value = approval_probability * 100,
                        domain = {'x': [0, 1], 'y': [0, 1]},
                        title = {'text': "T·ª∑ L·ªá ƒê∆∞·ª£c Duy·ªát Cho Vay (%)"},
                        gauge = {
                            'axis': {'range': [None, 100]},
                            'bar': {'color': "green"},
                            'steps': [
                                {'range': [0, 30], 'color': "lightcoral"},
                                {'range': [30, 60], 'color': "yellow"},
                                {'range': [60, 100], 'color': "lightgreen"}
                            ],
                            'threshold': {
                                'line': {'color': "darkgreen", 'width': 4},
                                'thickness': 0.75,
                                'value': 70
                            }
                        }
                    ))
                    
                    fig.update_layout(height=300, margin=dict(l=20, r=20, t=40, b=20))
                    st.plotly_chart(fig, use_container_width=True)
                
                # Calculate SHAP values for later use
                shap_result = None
                features_impact = {}
                
                try:
                    # Calculate real SHAP values
                    if hasattr(loader, 'shap_explainer') and loader.shap_explainer:
                        shap_result = loader.calculate_shap_for_sample(input_data)
                        
                        # Get features_impact for later use
                        features_in_vietnamese = {
                            'person_age': 'Tu·ªïi',
                            'person_income': 'Thu nh·∫≠p', 
                            'person_home_ownership': 'T√¨nh tr·∫°ng s·ªü h·ªØu nh√†',
                            'person_emp_length': 'Th·ªùi gian l√†m vi·ªác',
                            'loan_intent': 'M·ª•c ƒë√≠ch vay',
                            'loan_amnt': 'S·ªë ti·ªÅn vay',
                            'cb_person_default_on_file': 'L·ªãch s·ª≠ n·ª£ x·∫•u',
                            'cb_person_cred_hist_length': 'L·ªãch s·ª≠ t√≠n d·ª•ng'
                        }
                        
                        for eng_name, viet_name in features_in_vietnamese.items():
                            features_impact[f"{viet_name} ({eng_name})"] = shap_result['shap_values'][eng_name]
                        
                    else:
                        # Fallback to simulated SHAP if real SHAP not available
                        st.warning("‚ö†Ô∏è SHAP TreeExplainer kh√¥ng c√≥ s·∫µn, s·ª≠ d·ª•ng ph√¢n t√≠ch m√¥ ph·ªèng")
                        base_score = 0.3  # baseline
                        features_impact = {
                            'Thu nh·∫≠p (person_income)': calculate_income_impact(person_income, loan_amount),
                            'S·ªë ti·ªÅn vay (loan_amnt)': calculate_loan_amount_impact(loan_amount, person_income),
                            'Tu·ªïi (person_age)': calculate_age_impact(person_age),
                            'L·ªãch s·ª≠ t√≠n d·ª•ng (cb_person_cred_hist_length)': calculate_credit_history_impact(credit_hist_length),
                            'T√¨nh tr·∫°ng s·ªü h·ªØu nh√† (person_home_ownership)': calculate_home_ownership_impact(home_ownership),
                            'Th·ªùi gian l√†m vi·ªác (person_emp_length)': calculate_employment_impact(emp_length),
                            'M·ª•c ƒë√≠ch vay (loan_intent)': calculate_loan_intent_impact(loan_intent),
                            'L·ªãch s·ª≠ n·ª£ x·∫•u (cb_person_default_on_file)': calculate_default_impact(default_on_file)
                        }
                        
                except Exception as e:
                    st.error(f"‚ùå L·ªói t√≠nh to√°n SHAP: {e}")
                    # Fallback to simulated values
                    features_impact = {
                        'Thu nh·∫≠p (person_income)': calculate_income_impact(person_income, loan_amount),
                        'S·ªë ti·ªÅn vay (loan_amnt)': calculate_loan_amount_impact(loan_amount, person_income),
                        'Tu·ªïi (person_age)': calculate_age_impact(person_age),
                        'L·ªãch s·ª≠ t√≠n d·ª•ng (cb_person_cred_hist_length)': calculate_credit_history_impact(credit_hist_length),
                        'T√¨nh tr·∫°ng s·ªü h·ªØu nh√† (person_home_ownership)': calculate_home_ownership_impact(home_ownership),
                        'Th·ªùi gian l√†m vi·ªác (person_emp_length)': calculate_employment_impact(emp_length),
                        'M·ª•c ƒë√≠ch vay (loan_intent)': calculate_loan_intent_impact(loan_intent),
                        'L·ªãch s·ª≠ n·ª£ x·∫•u (cb_person_default_on_file)': calculate_default_impact(default_on_file)
                    }
                
                # Original SHAP Analysis section for detailed explanations
                st.markdown("---")
                st.markdown("### üîç PH√ÇN T√çCH CHI TI·∫æT C√ÅC Y·∫æU T·ªê (SHAP Analysis)")
                
                # Convert all impacts to percentage points (multiply by 100 for display)
                features_impact_percent = {name: impact * 100 for name, impact in features_impact.items()}
                
                # Separate positive and negative features, then sort by impact (descending)
                positive_features = [(name, impact_pct) for name, impact_pct in features_impact_percent.items() if impact_pct > 0]
                negative_features = [(name, impact_pct) for name, impact_pct in features_impact_percent.items() if impact_pct < 0]
                
                # Sort by impact: positive descending, negative by absolute value descending
                positive_features.sort(key=lambda x: x[1], reverse=True)
                negative_features.sort(key=lambda x: abs(x[1]), reverse=True)
                
                # Display positive factors
                if positive_features:
                    st.markdown("#### ‚úÖ C√ÅC Y·∫æU T·ªê T√çCH C·ª∞C (H·ªó tr·ª£ vi·ªác ƒë∆∞·ª£c duy·ªát)")
                    
                    for i, (feature_name, impact_pct) in enumerate(positive_features):
                        # impact_pct is already in percentage points
                        impact_score = f"+{impact_pct:.1f}%"
                        
                        if impact_pct >= 2.0:
                            impact_level = "R·∫§T M·∫†NH"
                            impact_color = "#1b5e20"
                            bg_color = "#c8e6c9"
                        elif impact_pct >= 1.0:
                            impact_level = "M·∫†NH"
                            impact_color = "#2e7d32"
                            bg_color = "#c8e6c9"
                        elif impact_pct >= 0.5:
                            impact_level = "TRUNG B√åNH"
                            impact_color = "#388e3c"
                            bg_color = "#dcedc8"
                        else:
                            impact_level = "NH·∫∏"
                            impact_color = "#4caf50"
                            bg_color = "#e8f5e8"
                        
                        st.markdown(f"""
                        <div style="
                            background-color: {bg_color};
                            border-left: 5px solid #4caf50;
                            padding: 15px;
                            border-radius: 8px;
                            margin: 10px 0;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <h5 style="margin: 0; color: {impact_color};">
                                    #{i+1} ‚úÖ {feature_name.split('(')[0].strip()}
                                </h5>
                                <div style="text-align: right;">
                                    <span style="font-size: 16px; font-weight: bold; color: {impact_color}; display: block;">
                                        {impact_level}
                                    </span>
                                    <span style="font-size: 14px; color: #666; background-color: white; padding: 3px 8px; border-radius: 10px; margin-top: 5px; display: inline-block;">
                                        {impact_score}
                                    </span>
                                </div>
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
                        
                        # Add explanation in an expander
                        with st.expander(f"üìñ Gi·∫£i th√≠ch chi ti·∫øt"):
                            explanation = get_feature_explanation(feature_name, impact_pct / 100, 
                                                                person_age, person_income, home_ownership, 
                                                                emp_length, loan_intent, loan_amount, 
                                                                default_on_file, credit_hist_length)
                            st.write(explanation)
                
                # Display negative factors
                if negative_features:
                    st.markdown("#### ‚ùå C√ÅC Y·∫æU T·ªê TI√äU C·ª∞C (C·∫£n tr·ªü vi·ªác ƒë∆∞·ª£c duy·ªát)")
                    
                    for i, (feature_name, impact_pct) in enumerate(negative_features):
                        # impact_pct is already in percentage points (and negative)
                        abs_impact_pct = abs(impact_pct)
                        impact_score = f"-{abs_impact_pct:.1f}%"
                        
                        if abs_impact_pct >= 2.0:
                            impact_level = "R·∫§T NGHI√äM TR·ªåNG"
                            impact_color = "#b71c1c"
                            bg_color = "#ffcdd2"
                        elif abs_impact_pct >= 1.0:
                            impact_level = "NGHI√äM TR·ªåNG"
                            impact_color = "#c62828"
                            bg_color = "#ffcdd2"
                        elif abs_impact_pct >= 0.5:
                            impact_level = "ƒê√ÅNG L∆ØU √ù"
                            impact_color = "#d32f2f"
                            bg_color = "#ffcdd2"
                        else:
                            impact_level = "NH·∫∏"
                            impact_color = "#f44336"
                            bg_color = "#ffeaea"
                        
                        st.markdown(f"""
                        <div style="
                            background-color: {bg_color};
                            border-left: 5px solid #f44336;
                            padding: 15px;
                            border-radius: 8px;
                            margin: 10px 0;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <h5 style="margin: 0; color: {impact_color};">
                                    #{i+1} ‚ùå {feature_name.split('(')[0].strip()}
                                </h5>
                                <div style="text-align: right;">
                                    <span style="font-size: 16px; font-weight: bold; color: {impact_color}; display: block;">
                                        {impact_level}
                                    </span>
                                    <span style="font-size: 14px; color: #666; background-color: white; padding: 3px 8px; border-radius: 10px; margin-top: 5px; display: inline-block;">
                                        {impact_score}
                                    </span>
                                </div>
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
                        
                        # Add explanation in an expander
                        with st.expander(f"üìñ Gi·∫£i th√≠ch chi ti·∫øt"):
                            explanation = get_feature_explanation(feature_name, impact_pct / 100, 
                                                                person_age, person_income, home_ownership, 
                                                                emp_length, loan_intent, loan_amount, 
                                                                default_on_file, credit_hist_length)
                            st.write(explanation)
                
                # Summary section
                st.markdown("#### üìà T·ªïng K·∫øt Ph√¢n T√≠ch")
                
                total_positive = sum(impact for _, impact in positive_features)
                total_negative = sum(impact for _, impact in negative_features)
                net_impact = total_positive + total_negative
                
                # Convert to user-friendly format
                def get_overall_score(net_impact):
                    net_percent = net_impact * 100
                    if net_percent >= 3.0:
                        return "XU·∫§T S·∫ÆC", f"+{net_percent:.1f}%", "#1b5e20"
                    elif net_percent >= 1.0:
                        return "T·ªêT", f"+{net_percent:.1f}%", "#2e7d32"
                    elif net_percent >= 0:
                        return "KHUY·∫æN KH√çCH", f"+{net_percent:.1f}%", "#388e3c"
                    elif net_percent >= -1.0:
                        return "C·∫¶N C·∫¢I THI·ªÜN", f"{net_percent:.1f}%", "#ff9800"
                    else:
                        return "C·∫¶N ƒêI·ªÄU CH·ªàNH", f"{net_percent:.1f}%", "#f44336"
                
                overall_rating, overall_score, overall_color = get_overall_score(net_impact)
                
                summary_col1, summary_col2, summary_col3 = st.columns(3)
                
                with summary_col1:
                    positive_count = len(positive_features)
                    positive_strength = "M·∫†NH" if total_positive > 0.02 else "TRUNG B√åNH" if total_positive > 0.01 else "Y·∫æU"
                    
                    st.markdown(f"""
                    <div style="
                        background-color: #e8f5e8;
                        border: 2px solid #4caf50;
                        padding: 15px;
                        border-radius: 8px;
                        text-align: center;
                    ">
                        <h4 style="color: #2e7d32; margin: 0;">‚úÖ Y·∫æU T·ªê T√çCH C·ª∞C</h4>
                        <p style="margin: 10px 0; font-size: 24px; font-weight: bold; color: #2e7d32;">
                            {positive_count} y·∫øu t·ªë
                        </p>
                        <p style="margin: 5px 0; color: #666; font-size: 16px; font-weight: bold;">
                            M·ª©c ƒë·ªô: {positive_strength}
                        </p>
                    </div>
                    """, unsafe_allow_html=True)
                
                with summary_col2:
                    negative_count = len(negative_features)
                    negative_strength = "NGHI√äM TR·ªåNG" if abs(total_negative) > 0.02 else "ƒê√ÅNG L∆ØU √ù" if abs(total_negative) > 0.01 else "NH·∫∏"
                    
                    st.markdown(f"""
                    <div style="
                        background-color: #ffeaea;
                        border: 2px solid #f44336;
                        padding: 15px;
                        border-radius: 8px;
                        text-align: center;
                    ">
                        <h4 style="color: #c62828; margin: 0;">‚ùå Y·∫æU T·ªê TI√äU C·ª∞C</h4>
                        <p style="margin: 10px 0; font-size: 24px; font-weight: bold; color: #c62828;">
                            {negative_count} y·∫øu t·ªë
                        </p>
                        <p style="margin: 5px 0; color: #666; font-size: 16px; font-weight: bold;">
                            M·ª©c ƒë·ªô: {negative_strength}
                        </p>
                    </div>
                    """, unsafe_allow_html=True)
                
                # Advice section
                st.markdown("---")
                st.markdown("### üí° L·ªúI KHUY√äN C·∫¢I THI·ªÜN H·ªí S∆†")
                advice = generate_advice(person_income, loan_amount, person_age, emp_length, 
                                       credit_hist_length, home_ownership, default_on_file, default_probability)
                
                # Display advice with proper line breaks
                st.markdown(f"""
                <div style="
                    background-color: #e3f2fd;
                    border-left: 4px solid #2196f3;
                    padding: 15px;
                    border-radius: 5px;
                    margin: 10px 0;
                ">
                    {advice.replace(chr(10), '<br>')}
                </div>
                """, unsafe_allow_html=True)
                
            except Exception as e:
                st.error(f"‚ùå L·ªói khi th·ª±c hi·ªán d·ª± ƒëo√°n: {e}")
        else:
            st.info("üëÜ Nh·∫•n n√∫t 'TH·ª∞C HI·ªÜN D·ª∞ ƒêO√ÅN R·ª¶I RO' ƒë·ªÉ xem k·∫øt qu·∫£")
    
    # Example buttons (outside of main columns)
    st.markdown("---")
    st.markdown("### üí° Th·ª≠ C√°c V√≠ D·ª• M·∫´u")
    
    example_col1, example_col2, example_col3 = st.columns(3)
    
    with example_col1:
        if st.button("üëç H·ªì S∆° T·ªët", use_container_width=True):
            st.rerun()
    
    with example_col2:
        if st.button("‚ö†Ô∏è H·ªì S∆° Trung B√¨nh", use_container_width=True):
            st.rerun()
    
    with example_col3:
        if st.button("‚ùå H·ªì S∆° R·ªßi Ro", use_container_width=True):
            st.rerun()

def render_lora_analysis(loader):
    """Render LORA model analysis"""
    st.markdown("# üß† Ph√¢n T√≠ch LORA Adapter Model")
    
    adapter_info = loader.get_adapter_summary()
    
    if "error" not in adapter_info:
        st.success("‚úÖ LORA Adapter ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng!")
        
        # Model overview
        st.markdown("## üìã Th√¥ng Tin T·ªïng Quan")
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("### C·∫•u H√¨nh M√¥ H√¨nh")
            st.info(f"**M√¥ H√¨nh G·ªëc:** {adapter_info.get('Base Model', 'N/A')}")
            st.info(f"**Lo·∫°i PEFT:** {adapter_info.get('PEFT Type', 'N/A')}")
            st.info(f"**Lo·∫°i T√°c V·ª•:** {adapter_info.get('Task Type', 'N/A')}")
            st.info(f"**Ch·∫ø ƒê·ªô Inference:** {'‚úÖ B·∫≠t' if adapter_info.get('Inference Mode') else '‚ùå T·∫Øt'}")
        
        with col2:
            st.markdown("### Tham S·ªë LoRA")
            st.metric("LoRA Rank (r)", adapter_info.get('LoRA Rank (r)', 0), help="Rank c√†ng th·∫•p c√†ng ti·∫øt ki·ªám t√†i nguy√™n")
            st.metric("LoRA Alpha", adapter_info.get('LoRA Alpha', 0), help="T·ª∑ l·ªá scaling cho LoRA weights")
            st.metric("LoRA Dropout", f"{adapter_info.get('LoRA Dropout', 0):.3f}", help="T·ª∑ l·ªá dropout ƒë·ªÉ tr√°nh overfitting")
        
        # Target modules
        target_modules = adapter_info.get('Target Modules', [])
        if target_modules:
            st.markdown("## üéØ Module M·ª•c Ti√™u")
            st.markdown("*C√°c layer ƒë∆∞·ª£c fine-tune b·∫±ng LoRA:*")
            cols = st.columns(min(len(target_modules), 4))
            for i, module in enumerate(target_modules):
                with cols[i % len(cols)]:
                    st.markdown(f"üì¶ **{module}**")
        
        # Advanced features
        st.markdown("## ‚öôÔ∏è T√≠nh NƒÉng N√¢ng Cao")
        adv_col1, adv_col2, adv_col3 = st.columns(3)
        
        with adv_col1:
            dora_status = "‚úÖ ƒê∆∞·ª£c b·∫≠t" if adapter_info.get('Use DoRA') else "‚ùå Kh√¥ng s·ª≠ d·ª•ng"
            st.markdown(f"**DoRA:** {dora_status}")
            if adapter_info.get('Use DoRA'):
                st.success("DoRA gi√∫p c·∫£i thi·ªán hi·ªáu su·∫•t fine-tuning")
        
        with adv_col2:
            qlora_status = "‚úÖ ƒê∆∞·ª£c b·∫≠t" if adapter_info.get('Use QLoRA') else "‚ùå Kh√¥ng s·ª≠ d·ª•ng"
            st.markdown(f"**QLoRA:** {qlora_status}")
            if adapter_info.get('Use QLoRA'):
                st.success("QLoRA gi√∫p ti·∫øt ki·ªám memory khi fine-tuning")
        
        with adv_col3:
            rslora_status = "‚úÖ ƒê∆∞·ª£c b·∫≠t" if adapter_info.get('Use RSLoRA', False) else "‚ùå Kh√¥ng s·ª≠ d·ª•ng"
            st.markdown(f"**RSLoRA:** {rslora_status}")
        
        # Technical details
        st.markdown("## üîß Chi Ti·∫øt K·ªπ Thu·∫≠t")
        with st.expander("Xem th√¥ng tin chi ti·∫øt"):
            st.json(adapter_info)
    else:
        st.error("‚ùå Kh√¥ng th·ªÉ t·∫£i c·∫•u h√¨nh LORA Adapter")

def render_lightgbm_analysis(loader):
    """Render LightGBM model analysis"""
    st.markdown("# üå≥ Ph√¢n T√≠ch LightGBM Model")
    
    lgb_info = loader.get_lightgbm_summary()
    
    if "error" not in lgb_info:
        st.success("‚úÖ LightGBM Model ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng!")
        
        # Model metrics
        st.markdown("## üìä Th√¥ng S·ªë M√¥ H√¨nh")
        metric_col1, metric_col2, metric_col3, metric_col4 = st.columns(4)
        
        with metric_col1:
            st.metric("S·ªë C√¢y (Trees)", lgb_info.get('Number of Trees', 0), help="S·ªë decision trees trong model")
        with metric_col2:
            st.metric("S·ªë ƒê·∫∑c Tr∆∞ng", lgb_info.get('Number of Features', 0), help="S·ªë features ƒë·∫ßu v√†o")
        with metric_col3:
            st.metric("S·ªë L·ªõp", lgb_info.get('Number of Classes', 1), help="Binary classification = 1")
        with metric_col4:
            objective = lgb_info.get('Objective', 'Unknown')
            st.metric("M·ª•c Ti√™u", objective, help="Lo·∫°i b√†i to√°n ML")
        
        # Feature information
        feature_names = lgb_info.get('Feature Names', [])
        if feature_names:
            st.markdown("## üè∑Ô∏è Danh S√°ch ƒê·∫∑c Tr∆∞ng")
            st.markdown("*C√°c th√¥ng tin ƒë·∫ßu v√†o m√† model s·ª≠ d·ª•ng ƒë·ªÉ d·ª± ƒëo√°n:*")
            
            # Create feature dataframe with Vietnamese names
            feature_mapping = {
                'person_age': 'üéÇ Tu·ªïi ng∆∞·ªùi vay',
                'person_income': 'üí∞ Thu nh·∫≠p h√†ng nƒÉm',
                'person_home_ownership': 'üè† T√¨nh tr·∫°ng nh√† ·ªü',
                'person_emp_length': 'üíº S·ªë nƒÉm l√†m vi·ªác',
                'loan_intent': 'üéØ M·ª•c ƒë√≠ch vay',
                'loan_amnt': 'üíµ S·ªë ti·ªÅn vay',
                'cb_person_default_on_file': '‚ö†Ô∏è L·ªãch s·ª≠ v·ª° n·ª£',
                'cb_person_cred_hist_length': 'üìä Th·ªùi gian c√≥ t√≠n d·ª•ng'
            }
            
            feature_df = pd.DataFrame({
                'STT': range(1, len(feature_names) + 1),
                'T√™n ƒê·∫∑c Tr∆∞ng': feature_names,
                'M√¥ T·∫£': [feature_mapping.get(name, name) for name in feature_names]
            })
            
            st.dataframe(feature_df, use_container_width=True, hide_index=True)
        
        # Model purpose
        st.markdown("## üéØ M·ª•c ƒê√≠ch C·ªßa Model")
        st.info("""
        **Model LightGBM n√†y ƒë∆∞·ª£c hu·∫•n luy·ªán ƒë·ªÉ:**
        - üîç D·ª± ƒëo√°n kh·∫£ nƒÉng v·ª° n·ª£ c·ªßa ng∆∞·ªùi vay
        - ‚öñÔ∏è ƒê√°nh gi√° r·ªßi ro t√≠n d·ª•ng
        - üí° H·ªó tr·ª£ quy·∫øt ƒë·ªãnh ph√™ duy·ªát kho·∫£n vay
        - üìà Ph√¢n t√≠ch c√°c y·∫øu t·ªë ·∫£nh h∆∞·ªüng ƒë·∫øn kh·∫£ nƒÉng tr·∫£ n·ª£
        """)
        
        # Performance insights
        st.markdown("## üìà Hi·ªáu Su·∫•t Model")
        perf_col1, perf_col2 = st.columns(2)
        
        with perf_col1:
            st.markdown("### ‚úÖ ∆Øu ƒêi·ªÉm")
            st.write("‚Ä¢ T·ªëc ƒë·ªô training v√† prediction nhanh")
            st.write("‚Ä¢ X·ª≠ l√Ω t·ªët d·ªØ li·ªáu c√≥ missing values")
            st.write("‚Ä¢ Hi·ªáu qu·∫£ v·ªõi b·ªô d·ªØ li·ªáu v·ª´a v√† l·ªõn")
            st.write("‚Ä¢ T·ª± ƒë·ªông feature selection")
        
        with perf_col2:
            st.markdown("### ‚ö†Ô∏è L∆∞u √ù")
            st.write("‚Ä¢ C·∫ßn ƒëi·ªÅu ch·ªânh hyperparameters c·∫©n th·∫≠n")
            st.write("‚Ä¢ C√≥ th·ªÉ overfitting v·ªõi d·ªØ li·ªáu nh·ªè")
            st.write("‚Ä¢ K·∫øt qu·∫£ ph·ª• thu·ªôc v√†o ch·∫•t l∆∞·ª£ng d·ªØ li·ªáu")
            st.write("‚Ä¢ C·∫ßn update ƒë·ªãnh k·ª≥ v·ªõi d·ªØ li·ªáu m·ªõi")
    else:
        st.error("‚ùå Kh√¥ng th·ªÉ t·∫£i LightGBM model")

def render_feature_importance(loader):
    """Render feature importance analysis"""
    st.markdown("# üìä Ph√¢n T√≠ch T·∫ßm Quan Tr·ªçng ƒê·∫∑c Tr∆∞ng")
    
    try:
        importance_df = loader.get_feature_importance()
        
        if not importance_df.empty:
            st.success("‚úÖ D·ªØ li·ªáu feature importance ƒë√£ ƒë∆∞·ª£c t·∫£i!")
            
            # Feature importance explanation
            st.markdown("## ü§î Feature Importance L√† G√¨?")
            st.info("""
            **Feature Importance** cho bi·∫øt m·ª©c ƒë·ªô quan tr·ªçng c·ªßa t·ª´ng ƒë·∫∑c tr∆∞ng trong vi·ªác ƒë∆∞a ra d·ª± ƒëo√°n:
            - **Gain**: T·ªïng improvement khi s·ª≠ d·ª•ng feature n√†y ƒë·ªÉ split
            - **Split**: S·ªë l·∫ßn feature ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ split trong c√°c decision trees
            """)
            
            # Create interactive charts
            fig = go.Figure()
            
            # Add gain importance
            fig.add_trace(go.Bar(
                name='Gain Importance',
                x=importance_df['importance_gain'],
                y=importance_df['feature'],
                orientation='h',
                marker_color='lightblue',
                text=importance_df['importance_gain'].round(0),
                textposition='outside'
            ))
            
            fig.update_layout(
                title='üìà T·∫ßm Quan Tr·ªçng ƒê·∫∑c Tr∆∞ng (Theo Gain)',
                xaxis_title='Importance Score',
                yaxis_title='Features',
                height=600,
                showlegend=False
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Top features analysis
            st.markdown("## üèÜ Top Features Quan Tr·ªçng Nh·∫•t")
            top_features = importance_df.head(5)
            
            for idx, row in top_features.iterrows():
                feature_name = row['feature']
                gain_score = row['importance_gain']
                split_count = row['importance_split']
                
                # Feature name mapping
                feature_descriptions = {
                    'person_income': 'üí∞ Thu nh·∫≠p l√† y·∫øu t·ªë quy·∫øt ƒë·ªãnh kh·∫£ nƒÉng tr·∫£ n·ª£',
                    'loan_amnt': 'üíµ S·ªë ti·ªÅn vay ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp ƒë·∫øn r·ªßi ro',
                    'person_home_ownership': 'üè† T√¨nh tr·∫°ng nh√† ·ªü th·ªÉ hi·ªán t√†i s·∫£n ƒë·∫£m b·∫£o',
                    'loan_intent': 'üéØ M·ª•c ƒë√≠ch vay cho th·∫•y m·ª©c ƒë·ªô c·∫ßn thi·∫øt',
                    'cb_person_default_on_file': '‚ö†Ô∏è L·ªãch s·ª≠ v·ª° n·ª£ l√† ch·ªâ s·ªë r·ªßi ro quan tr·ªçng',
                    'person_age': 'üéÇ Tu·ªïi t√°c ph·∫£n √°nh kinh nghi·ªám v√† ·ªïn ƒë·ªãnh',
                    'person_emp_length': 'üíº Th·ªùi gian l√†m vi·ªác th·ªÉ hi·ªán ·ªïn ƒë·ªãnh thu nh·∫≠p',
                    'cb_person_cred_hist_length': 'üìä L·ªãch s·ª≠ t√≠n d·ª•ng d√†i cho th·∫•y kinh nghi·ªám'
                }
                
                with st.expander(f"#{idx+1}: {feature_name} (Score: {gain_score:.0f})"):
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("Gain Score", f"{gain_score:.0f}")
                        st.metric("Split Count", f"{split_count}")
                    with col2:
                        description = feature_descriptions.get(feature_name, "ƒê·∫∑c tr∆∞ng quan tr·ªçng trong m√¥ h√¨nh")
                        st.write(description)
            
            # Feature importance table
            st.markdown("## üìã B·∫£ng ƒê·∫ßy ƒê·ªß Feature Importance")
            
            # Add Vietnamese descriptions
            importance_df_display = importance_df.copy()
            feature_vietnamese = {
                'person_age': 'Tu·ªïi ng∆∞·ªùi vay',
                'person_income': 'Thu nh·∫≠p h√†ng nƒÉm',
                'person_home_ownership': 'T√¨nh tr·∫°ng nh√† ·ªü',
                'person_emp_length': 'S·ªë nƒÉm l√†m vi·ªác',
                'loan_intent': 'M·ª•c ƒë√≠ch vay',
                'loan_amnt': 'S·ªë ti·ªÅn vay',
                'cb_person_default_on_file': 'L·ªãch s·ª≠ v·ª° n·ª£',
                'cb_person_cred_hist_length': 'Th·ªùi gian c√≥ t√≠n d·ª•ng'
            }
            
            importance_df_display['T√™n Ti·∫øng Vi·ªát'] = importance_df_display['feature'].map(feature_vietnamese)
            importance_df_display = importance_df_display[['feature', 'T√™n Ti·∫øng Vi·ªát', 'importance_gain', 'importance_split']]
            importance_df_display.columns = ['Feature (EN)', 'T√™n Ti·∫øng Vi·ªát', 'Gain Score', 'Split Count']
            
            st.dataframe(importance_df_display, use_container_width=True, hide_index=True)
            
        else:
            st.warning("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu feature importance")
    except Exception as e:
        st.error(f"‚ùå L·ªói khi t·∫°o bi·ªÉu ƒë·ªì feature importance: {e}")

if __name__ == "__main__":
    main()